<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SimpleGame_1 · Galaga-like</title>
  <style>
    html,body{height:100%;margin:0;background:#0a0a0a;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    .wrap{display:grid;place-items:center;min-height:100%;padding:12px}
    .game{position:relative}
    canvas{border-radius:16px;box-shadow:0 20px 50px rgba(0,0,0,.6);outline:1px solid rgba(255,255,255,.08)}
    .ui{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column}
    .top{display:flex;justify-content:space-between;gap:8px;padding:10px}
    .btns{display:flex;gap:8px;pointer-events:auto}
    .btn{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.12);color:#fff;border-radius:12px;padding:6px 10px;cursor:pointer}
    .btn:hover{background:rgba(255,255,255,.2)}
    .hint{margin-top:auto;text-align:center;color:rgba(255,255,255,.8);padding:8px}
    .modal{position:absolute;inset:0;display:grid;place-items:center}
    .card{pointer-events:auto;background:rgba(20,20,20,.9);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.12);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.5);padding:24px;text-align:center;max-width:420px;width:86%}
    .touch{position:absolute;left:0;right:0;bottom:8px;display:flex;justify-content:space-between;gap:8px;padding:0 12px;pointer-events:none}
    .tbtn{pointer-events:auto;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.12);color:#fff;border-radius:12px;font-weight:600;padding:12px 18px}
    .tbtn:active{background:rgba(255,255,255,.2)}
    @media (max-width:860px){.game{transform:scale(.7)}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game" id="game" style="width:800px;height:1000px">
      <canvas id="cv" width="800" height="1000"></canvas>
      <div class="ui">
        <div class="top">
          <div id="title" style="color:#ddd">Galaga-like</div>
          <div class="btns">
            <button class="btn" id="pauseBtn">일시정지 (P)</button>
            <button class="btn" id="restartBtn">다시시작 (R)</button>
          </div>
        </div>
        <div class="hint" id="hint">← → 0.1초 스텝 이동 · Space 발사</div>
      </div>
      <div class="modal" id="startModal">
        <div class="card">
          <h2 style="margin:0 0 6px;font-size:22px">갤러그 시작</h2>
          <p style="margin:0 0 14px;color:#bbb">← → 이동(0.1초 간격) · Space 발사 · P 일시정지 · R 재시작</p>
          <button class="btn" id="startBtn" style="background:white;color:black">START</button>
        </div>
      </div>
      <div class="modal" id="overModal" style="display:none">
        <div class="card">
          <h2 style="margin:0 0 6px;font-size:22px">GAME OVER</h2>
          <p id="overText" style="margin:0 0 14px;color:#bbb"></p>
          <button class="btn" id="restartBtn2" style="background:white;color:black">RESTART</button>
        </div>
      </div>
      <div class="touch" id="touchBar" style="display:none">
        <button class="tbtn" id="tLeft">◀</button>
        <button class="tbtn" id="tRight">▶</button>
        <button class="tbtn" id="tFire" style="padding:12px 28px">FIRE</button>
      </div>
    </div>
  </div>

<script>
// ======= No build, no imports. Plain JS only. =======
(function(){
  const GAME_W = 800, GAME_H = 1000;
  const PLAYER_SPEED = 420; // for reference
  const STEP_MS = 100; // 0.1s interval
  const STEP_PX = Math.round(PLAYER_SPEED * (STEP_MS/1000)); // ≈42px/step
  const BULLET_SPEED = 700;
  const ENEMY_BULLET_SPEED = 340;
  const FIRE_COOLDOWN = 180;
  const MAX_LIVES = 3;
  const WAVE_BASE = 24;

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const startModal = document.getElementById('startModal');
  const overModal = document.getElementById('overModal');
  const overText = document.getElementById('overText');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const restartBtn2 = document.getElementById('restartBtn2');
  const startBtn = document.getElementById('startBtn');
  const titleEl = document.getElementById('title');
  const hintEl = document.getElementById('hint');
  const touchBar = document.getElementById('touchBar');
  const tLeft = document.getElementById('tLeft');
  const tRight = document.getElementById('tRight');
  const tFire = document.getElementById('tFire');

  let running = false, paused = false, gameOver = false;
  let score = 0, lives = MAX_LIVES, wave = 1;
  let lastT = 0;

  const keys = Object.create(null);
  const player = { x: GAME_W/2 - 20, y: GAME_H - 120, w: 40, h: 30, cooldown: 0 };
  let bullets = []; // {x,y,vy,fromEnemy}
  let enemies = []; // {x,y,vx,vy,alive,kind,inDive,cool}

  // Touch detection
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isTouch) touchBar.style.display = 'flex';

  // Step-based movement timer
  let moveTimer = null;
  function ensureMoveTimer(){
    if (moveTimer) return;
    moveTimer = setInterval(() => {
      if (!running || paused) return;
      let dir = 0;
      if (keys['ArrowLeft']) dir -= 1;
      if (keys['ArrowRight']) dir += 1;
      if (dir !== 0){
        player.x = clamp(player.x + dir*STEP_PX, 12, GAME_W - player.w - 12);
      }
    }, STEP_MS);
  }
  function stopMoveTimer(){ if (moveTimer){ clearInterval(moveTimer); moveTimer = null; } }

  // Events
  window.addEventListener('keydown', (e) => {
    if (['ArrowLeft','ArrowRight','Space','KeyP','KeyR'].includes(e.code)) e.preventDefault();
    if (e.code === 'KeyP'){ paused = !paused; updatePauseLabel(); return; }
    if (e.code === 'KeyR'){ start(); return; }
    keys[e.code] = true;
    if (e.code === 'Space' && player.cooldown <= 0){
      bullets.push({ x: player.x + player.w/2, y: player.y, vy: -BULLET_SPEED });
      player.cooldown = FIRE_COOLDOWN;
    }
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') ensureMoveTimer();
  }, { passive:false });
  window.addEventListener('keyup', (e) => {
    if (['ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    keys[e.code] = false;
    if (!keys['ArrowLeft'] && !keys['ArrowRight']) stopMoveTimer();
  }, { passive:false });
  window.addEventListener('blur', () => { for (const k in keys) delete keys[k]; stopMoveTimer(); });

  // Touch buttons
  tLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys['ArrowLeft']=true; ensureMoveTimer(); }, {passive:false});
  tLeft.addEventListener('touchend',   (e)=>{ e.preventDefault(); keys['ArrowLeft']=false; if(!keys['ArrowRight']) stopMoveTimer(); }, {passive:false});
  tRight.addEventListener('touchstart',(e)=>{ e.preventDefault(); keys['ArrowRight']=true; ensureMoveTimer(); }, {passive:false});
  tRight.addEventListener('touchend',  (e)=>{ e.preventDefault(); keys['ArrowRight']=false; if(!keys['ArrowLeft']) stopMoveTimer(); }, {passive:false});
  tFire.addEventListener('touchstart', (e)=>{ e.preventDefault(); tryFire(); }, {passive:false});

  pauseBtn.onclick = ()=>{ paused = !paused; updatePauseLabel(); };
  restartBtn.onclick = ()=> start();
  restartBtn2.onclick = ()=> start();
  startBtn.onclick = ()=> start();

  function updatePauseLabel(){
    pauseBtn.textContent = paused ? '재개 (P)' : '일시정지 (P)';
  }

  // Helpers
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  // Waves
  function buildWave(n){
    const cols = 8; const rows = Math.ceil(n/cols);
    const gapX = 80, gapY = 70;
    const startX = (GAME_W - (cols - 1)*gapX)/2;
    const startY = 120;
    enemies = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        if (enemies.length>=n) break;
        const kind = r===0?2:(r<2?1:0);
        enemies.push({
          x: startX + c*gapX,
          y: startY + r*gapY,
          vx: 60 * (Math.random()<.5?1:-1),
          vy: 0,
          alive: true,
          kind,
          inDive: false,
          cool: rand(0,2)
        });
      }
    }
  }

  function tryFire(){
    if (player.cooldown <= 0){
      bullets.push({ x: player.x + player.w/2, y: player.y, vy: -BULLET_SPEED });
      player.cooldown = FIRE_COOLDOWN;
    }
  }

  function enemyFireMaybe(dt){
    for (const e of enemies){
      if (!e.alive) continue;
      e.cool -= dt;
      if (e.cool <= 0 && Math.random() < 0.02){
        bullets.push({ x: e.x, y: e.y+14, vy: ENEMY_BULLET_SPEED, fromEnemy:true });
        e.cool = rand(.8, 2.0);
      }
      if (!e.inDive && Math.random() < 0.0015){
        e.inDive = true;
        const dx = (player.x+player.w/2) - e.x;
        const dy = player.y - e.y;
        const len = Math.hypot(dx,dy)||1;
        e.vx = (dx/len)*180; e.vy = (dy/len)*180;
      }
      if (e.inDive){ e.vy += 40 * dt; }
    }
  }

  function start(){
    score = 0; lives = MAX_LIVES; wave = 1;
    player.x = GAME_W/2 - 20; player.y = GAME_H - 120; player.cooldown = 200;
    bullets = []; gameOver = false; running = true; paused = false; updatePauseLabel();
    buildWave(WAVE_BASE);
    startModal.style.display = 'none';
    overModal.style.display = 'none';
    hintEl.textContent = '행운을! (P: 일시정지)';
  }

  // MAIN LOOP
  function loop(t){
    if (!lastT) lastT = t; const dt = Math.min(.033, (t-lastT)/1000); lastT = t;

    // UPDATE
    if (running && !paused){
      // shooting cooldown
      player.cooldown -= dt*1000;

      // bullets
      bullets = bullets.map(b => ({...b, y: b.y + b.vy*dt}))
                       .filter(b => b.y > -30 && b.y < GAME_H + 30);

      // enemies
      for (const e of enemies){
        if (!e.alive) continue;
        e.x += e.vx*dt; e.y += e.vy*dt;
        if (!e.inDive){
          if (e.x < 60 || e.x > GAME_W - 60) e.vx *= -1;
          e.y += Math.sin(t/300 + e.x*.01) * 10 * dt;
        } else {
          if (e.y > GAME_H - 200){ e.inDive=false; e.vx=60*(Math.random()<.5?1:-1); e.vy=0; e.y = clamp(e.y,120,GAME_H-300); }
        }
      }

      enemyFireMaybe(dt);

      // collisions
      const pb = bullets.filter(b => !b.fromEnemy);
      const eb = bullets.filter(b =>  b.fromEnemy);

      for (const b of pb){
        for (const e of enemies){
          if (!e.alive) continue;
          if (rectsOverlap({x:b.x-2,y:b.y-8,w:4,h:16}, {x:e.x-16,y:e.y-12,w:32,h:24})){
            e.alive = false; b.y = -9999; score += (e.kind===2?150:(e.kind===1?80:40)); break;
          }
        }
      }
      bullets = [...pb,...eb].filter(b => b.y > -30 && b.y < GAME_H + 30);

      // player hit
      const pr = { x:player.x, y:player.y, w:player.w, h:player.h };
      let hit = false;
      for (const b of eb){ if (rectsOverlap({x:b.x-2,y:b.y-8,w:4,h:16}, pr)){ hit=true; b.y = 9999; } }
      for (const e of enemies){ if (e.alive && rectsOverlap({x:e.x-16,y:e.y-12,w:32,h:24}, pr)){ hit=true; e.alive=false; } }
      if (hit){
        lives -= 1;
        if (lives <= 0){ gameOver = true; running = false; overText.textContent = `점수 ${score} · Wave ${wave}`; overModal.style.display='block'; }
        else { player.x = GAME_W/2 - 20; player.y = GAME_H - 120; player.cooldown = 400; }
      }

      // wave cleared
      if (enemies.every(e => !e.alive)){
        wave += 1; hintEl.textContent = '적 증원! 난이도 상승';
        bullets = bullets.filter(b => !b.fromEnemy);
        setTimeout(()=>{ buildWave(Math.min(WAVE_BASE + (wave-1)*6, 48)); }, 300);
      }
    }

    // RENDER
    ctx.clearRect(0,0,GAME_W,GAME_H);
    // bg
    ctx.fillStyle = 'black'; ctx.fillRect(0,0,GAME_W,GAME_H);
    ctx.fillStyle = 'white';
    for (let i=0;i<80;i++){ const y = (t*.05 + (i*120)) % GAME_H; const x = (i*97) % GAME_W; ctx.fillRect(x,y,2,2); }

    // HUD
    ctx.fillStyle = 'white'; ctx.font = '24px ui-sans-serif,system-ui,-apple-system';
    ctx.fillText('SCORE '+score, 20, 36);
    ctx.fillText('WAVE '+wave, GAME_W-140, 36);
    for (let i=0;i<lives;i++){ ctx.save(); ctx.translate(20+i*28,58); ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(6,6); ctx.lineTo(0,3); ctx.lineTo(-6,6); ctx.closePath(); ctx.fill(); ctx.restore(); }

    // enemies
    for (const e of enemies){ if (!e.alive) continue; ctx.save(); ctx.translate(e.x,e.y); const colors=['#F2C94C','#BB6BD9','#2D9CDB']; ctx.fillStyle=colors[e.kind]||'#F2C94C'; ctx.fillRect(-16,-12,32,24); ctx.fillStyle='black'; ctx.fillRect(-10,-4,20,8); ctx.fillStyle='white'; ctx.fillRect(-8,-2,4,4); ctx.fillRect(4,-2,4,4); ctx.restore(); }

    // player
    ctx.save(); ctx.translate(player.x+player.w/2, player.y+player.h/2); ctx.fillStyle='white'; ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(14,10); ctx.lineTo(0,6); ctx.lineTo(-14,10); ctx.closePath(); ctx.fill(); ctx.fillStyle='#56CCF2'; ctx.fillRect(-4,-6,8,8); ctx.fillStyle='#EB5757'; ctx.fillRect(-18,6,8,6); ctx.fillRect(10,6,8,6); ctx.restore();

    // bullets
    for (const b of bullets){ ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle = b.fromEnemy?'#F2994A':'#6FCF97'; ctx.fillRect(-2,-8,4,16); ctx.restore(); }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
